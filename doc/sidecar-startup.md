# 侧车服务启动方案

本文档说明 Node 侧车（core → langchain-serve + pty-host）的**启动时机**、**启动位置**以及**如何保证只启动一次**。

---

## 1. 何时启动：随程序开始

- **推荐**：在**应用启动时**就启动侧车（随程序开始）。
- **不推荐**：在「进入某个路由后」再启动。

**原因**：

- 侧车是进程级服务，生命周期应与整个应用一致。
- 若改为「进路由再启」：
  - 每次进入该路由都要判断是否已启过，逻辑分散、易漏；
  - 用户不访问该路由则服务永远不启；
  - 路由来回切换容易造成重复 spawn 或漏启。

因此采用**随程序开始、只启一次**。

---

## 2. 在哪里启动：Rust 应用生命周期内（单点）

- **推荐**：在 **Tauri 的 Rust 侧**、应用**只执行一次的时机**里 spawn 一次 core 侧车。
- **不推荐**：在前端（Vue）里根据路由或按钮去调「启动侧车」。

**原因**：

- 若在前端「进某页 / 某路由时」才调 `invoke('startCore')`，每次进路由都可能触发，需要自己做防重复；
- 刷新、多窗口、路由守卫不完善时，容易重复启动。
- 在 Rust 的 `setup` 或主窗口首次 Ready 里 spawn，**单点、单次**，天然只走一次。

**推荐写法位置**：

- 使用 Tauri 的 **`setup` 回调**：`tauri::Builder::default().setup(|app| { ... })` 里 spawn core 侧车；
- 或使用**主窗口的 `WindowEvent::Ready`**，仅对 main 窗口第一次 Ready 时 spawn 一次。

---

## 3. 如何保证两个侧车「只会走一次」

### 3.1 单点 spawn

只在上述 Rust `setup`（或第一次 Ready）里调用**一次**「启动 core 侧车」的逻辑。不在路由、不在前端、不在其它地方再 spawn。

### 3.2 依赖 core 自身行为

core 不传参时会 `spawnWorker("langchain-serve")` 和 `spawnWorker("pty-host")` 各一次，两个子进程常驻；只要不重复执行 core，两个侧车就只会被起一次。

### 3.3 可选：防重复保护

若后续可能从多处（例如前端）触发「启动 core」，可在 Rust 里加防重复：

- 使用 `std::sync::Once` 或 `OnceCell`；
- 在真正 spawn 前执行 `STARTED.call_once(|| { ... spawn sidecar ... });`，保证逻辑只执行一次。

### 3.4 不要做的事

- 不要在「进入某路由时」在前端调用启动；
- 不要在多个页面的 `onMounted` 里都调启动。

---

## 4. 实现要点小结

| 项目     | 做法                                       |
|----------|--------------------------------------------|
| **时机** | 应用启动时（随程序开始）                   |
| **位置** | Rust：`Builder::default().setup(\|app\| { ... })` 或主窗口首次 Ready |
| **次数** | 仅此一处 spawn；可选 `Once`/`OnceCell` 防重复 |
| **前端** | 不负责启动侧车，只使用已启动好的端口/服务 |

按此方案，两个侧车在进程生命周期内**只会启动一次**，不会因路由切换或重复调用而重新拉起。
